---
// Background Music Component with Mute Toggle
// Uses transition:persist with unique name to maintain playback across page navigation
---

<div id="music-controls" class="fixed bottom-6 right-6 z-50" transition:persist="music-controls">
  <button
    id="music-toggle"
    class="bg-[#0a0f0a]/90 backdrop-blur-sm border border-primary-green/30 rounded-full p-3 hover:bg-[#0a0f0a] hover:border-primary-green transition-all duration-300 group"
    aria-label="Toggle background music"
  >
    <svg id="music-icon-playing" class="w-6 h-6 text-primary-green" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M9 18V5l12-2v13" />
      <circle cx="6" cy="18" r="3" />
      <circle cx="18" cy="16" r="3" />
    </svg>
    <svg id="music-icon-muted" class="w-6 h-6 text-gray-500 hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M9 18V5l12-2v13" />
      <circle cx="6" cy="18" r="3" />
      <circle cx="18" cy="16" r="3" />
      <line x1="1" y1="1" x2="23" y2="23" />
    </svg>
  </button>
</div>

<!-- eslint-disable-next-line jsx-a11y/media-has-caption -->
<audio id="background-music" loop preload="auto" transition:persist="background-audio">
  <source src="/audio/main-menu-theme.wav" type="audio/wav">
  <!-- No caption track needed as this is background music without spoken content -->
  Your browser does not support the audio element.
</audio>

<style>
  #music-controls {
    animation: fadeIn 1s ease-in;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  #music-toggle:hover svg {
    transform: scale(1.1);
  }

  #music-toggle svg {
    transition: transform 0.2s ease;
  }
</style>

<script>
  // Background Music Controller with View Transitions support and consent handling
  class BackgroundMusicController {
    private audio: HTMLAudioElement | null
    private toggleBtn: HTMLElement | null
    private playingIcon: HTMLElement | null
    private mutedIcon: HTMLElement | null
    private isMuted: boolean
    private consentKey = 'audioConsentGiven'

    constructor() {
      this.audio = document.getElementById('background-music') as HTMLAudioElement
      this.toggleBtn = document.getElementById('music-toggle')
      this.playingIcon = document.getElementById('music-icon-playing')
      this.mutedIcon = document.getElementById('music-icon-muted')

      // Get saved preference from localStorage
      this.isMuted = localStorage.getItem('bgMusicMuted') === 'true'

      this.init()
    }

    init() {
      if (!this.audio || !this.toggleBtn) return

      // Set initial state
      this.audio.volume = 0.3 // 30% volume
      this.updateUI()

      // Listen for consent event from AudioConsentModal
      window.addEventListener('audioConsentGranted', () => {
        this.handleConsentGranted()
      })

      // Check if consent was already given and audio should auto-play
      const consent = localStorage.getItem(this.consentKey)
      if (consent === 'true' && !this.isMuted) {
        this.tryAutoplay()
      }

      // Toggle button click handler
      this.toggleBtn.addEventListener('click', () => this.toggle())

      // Handle page visibility changes (pause when tab is hidden)
      document.addEventListener('visibilitychange', () => {
        if (!this.audio) return
        
        if (document.hidden) {
          // Don't pause - let audio continue in background
          // Modern browsers handle this automatically
        } else if (!this.isMuted && this.audio.paused) {
          // Resume if returning to tab and audio was supposed to be playing
          this.audio.play().catch(() => {
            // Autoplay prevented, user needs to interact
          })
        }
      })
    }

    async handleConsentGranted() {
      // User granted consent via modal, start playing
      if (!this.isMuted) {
        try {
          await this.audio!.play()
          console.log('Audio playback started after consent')
        } catch (error) {
          console.log('Failed to start audio after consent:', error)
        }
      }
    }

    async tryAutoplay() {
      if (this.isMuted) {
        return
      }

      try {
        await this.audio!.play()
      } catch (error) {
        // Autoplay prevented by browser policy
        // Music will start when user grants consent via modal or clicks the toggle
        console.log('Autoplay prevented. Waiting for user consent.')
      }
    }

    toggle() {
      this.isMuted = !this.isMuted
      localStorage.setItem('bgMusicMuted', this.isMuted.toString())

      if (this.isMuted) {
        this.audio!.pause()
      } else {
        this.audio!.play().catch(() => {
          console.error('Failed to play audio')
        })
      }

      this.updateUI()
    }

    updateUI() {
      if (this.isMuted) {
        this.playingIcon?.classList.add('hidden')
        this.mutedIcon?.classList.remove('hidden')
      } else {
        this.playingIcon?.classList.remove('hidden')
        this.mutedIcon?.classList.add('hidden')
      }
    }
  }

  // Initialize on page load and after View Transitions
  let musicController: BackgroundMusicController | null = null

  const initMusic = () => {
    // Only create a new controller if one doesn't exist
    // This prevents re-initialization when audio persists across pages
    if (!musicController) {
      musicController = new BackgroundMusicController()
    } else {
      // Controller exists, just re-wire the DOM elements after navigation
      // This ensures the toggle button works after page transition
      const toggleBtn = document.getElementById('music-toggle')
      const playingIcon = document.getElementById('music-icon-playing')
      const mutedIcon = document.getElementById('music-icon-muted')
      
      if (toggleBtn && musicController) {
        // Re-attach click listener
        toggleBtn.replaceWith(toggleBtn.cloneNode(true))
        const newToggleBtn = document.getElementById('music-toggle')
        newToggleBtn?.addEventListener('click', () => musicController!.toggle())
      }
    }
  }

    // Initialize on first load
  if (typeof window !== 'undefined') {
    // Initialize immediately if audio element exists
    if (document.getElementById('background-music')) {
      initMusic()
    }
  }

  // Handle View Transitions - audio element persists, just update references
  document.addEventListener('astro:after-swap', () => {
    // Re-initialize to wire up new DOM references
    const audio = document.getElementById('background-music') as HTMLAudioElement
    const toggleBtn = document.getElementById('music-toggle')
    
    if (audio && toggleBtn && musicController) {
      // Update private properties via any cast (TypeScript workaround for private access)
      // This is necessary because the DOM elements are recreated during View Transitions
      (musicController as any).audio = audio;
      (musicController as any).toggleBtn = toggleBtn;
      (musicController as any).playingIcon = document.getElementById('music-icon-playing');
      (musicController as any).mutedIcon = document.getElementById('music-icon-muted');
      
      // Remove any existing listeners to avoid duplicates, then re-attach
      const newToggleBtn = toggleBtn.cloneNode(true) as HTMLElement
      toggleBtn.parentNode?.replaceChild(newToggleBtn, toggleBtn)
      
      // Re-attach event listener to cloned button element
      newToggleBtn.addEventListener('click', () => musicController!.toggle())
      
      // Update controller reference to new button
      (musicController as any).toggleBtn = newToggleBtn
      
      // Update UI to reflect current state
      musicController.updateUI()
    } else if (audio && toggleBtn && !musicController) {
      // Shouldn't happen, but initialize if needed
      initMusic()
    }
  })

  // Prevent audio from pausing during page transitions
  document.addEventListener('astro:before-preparation', () => {
    // This event fires before the transition starts
    // The audio element will persist, so no action needed
  })

  document.addEventListener('astro:before-swap', () => {
    // This event fires right before the DOM swap
    // The audio element will persist due to transition:persist
  })
</script>
