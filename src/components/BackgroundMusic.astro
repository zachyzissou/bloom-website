---
// Background Music Component with Mute Toggle
// Uses transition:persist with unique name to maintain playback across page navigation
---

<div id="music-controls" class="fixed bottom-6 right-6 z-50" transition:persist="music-controls">
  <button
    id="music-toggle"
    class="bg-[#0a0f0a]/90 backdrop-blur-sm border border-primary-green/30 rounded-full p-3 hover:bg-[#0a0f0a] hover:border-primary-green transition-all duration-300 group"
    aria-label="Toggle background music"
  >
    <svg id="music-icon-playing" class="w-6 h-6 text-primary-green" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M9 18V5l12-2v13" />
      <circle cx="6" cy="18" r="3" />
      <circle cx="18" cy="16" r="3" />
    </svg>
    <svg id="music-icon-muted" class="w-6 h-6 text-gray-500 hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M9 18V5l12-2v13" />
      <circle cx="6" cy="18" r="3" />
      <circle cx="18" cy="16" r="3" />
      <line x1="1" y1="1" x2="23" y2="23" />
    </svg>
  </button>
</div>

<!-- eslint-disable-next-line jsx-a11y/media-has-caption -->
<audio id="background-music" loop preload="auto" transition:persist="background-audio">
  <source src="/audio/main-menu-theme.wav" type="audio/wav">
  <!-- No caption track needed as this is background music without spoken content -->
  Your browser does not support the audio element.
</audio>

<style>
  #music-controls {
    animation: fadeIn 1s ease-in;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  #music-toggle:hover svg {
    transform: scale(1.1);
  }

  #music-toggle svg {
    transition: transform 0.2s ease;
  }
</style>

<script>
  // Background Music Controller with View Transitions support and consent handling
  class BackgroundMusicController {
    private audio: HTMLAudioElement | null
    private toggleBtn: HTMLElement | null
    private playingIcon: HTMLElement | null
    private mutedIcon: HTMLElement | null
    private isMuted: boolean
    private consentKey = 'audioConsentGiven'
    private toggleHandler: (() => void) | null = null
    private visibilityHandler: (() => void) | null = null
    private consentHandler: (() => void) | null = null
    private beforeSwapHandler: (() => void) | null = null
    private afterSwapHandler: (() => void) | null = null
    private savedPlaybackState: { currentTime: number; paused: boolean } | null = null

    constructor() {
      this.audio = document.getElementById('background-music') as HTMLAudioElement
      this.toggleBtn = document.getElementById('music-toggle')
      this.playingIcon = document.getElementById('music-icon-playing')
      this.mutedIcon = document.getElementById('music-icon-muted')

      // Get saved preference from localStorage
      this.isMuted = localStorage.getItem('bgMusicMuted') === 'true'

      this.init()
    }

    init() {
      if (!this.audio || !this.toggleBtn) return

      // Set initial state
      this.audio.volume = 0.3 // 30% volume
      this.updateUI()

      // Set up event handlers (stored to allow removal)
      this.consentHandler = () => this.handleConsentGranted()
      this.toggleHandler = () => this.toggle()
      this.visibilityHandler = () => {
        if (!this.audio) return
        
        if (document.hidden) {
          // Don't pause - let audio continue in background
          // Modern browsers handle this automatically
        } else if (!this.isMuted && this.audio.paused) {
          // Resume if returning to tab and audio was supposed to be playing
          this.audio.play().catch(() => {
            // Autoplay prevented, user needs to interact
          })
        }
      }

      // Preserve audio state before View Transition swap
      this.beforeSwapHandler = () => {
        if (this.audio) {
          this.savedPlaybackState = {
            currentTime: this.audio.currentTime,
            paused: this.audio.paused
          }
        }
      }

      // Restore audio state after View Transition swap
      this.afterSwapHandler = () => {
        const audio = document.getElementById('background-music') as HTMLAudioElement
        const toggleBtn = document.getElementById('music-toggle')
        
        if (audio && toggleBtn) {
          // Update DOM references
          this.updateDOMReferences(audio, toggleBtn)
          
          // Restore playback state if it was saved
          if (this.savedPlaybackState && audio) {
            audio.currentTime = this.savedPlaybackState.currentTime
            if (!this.savedPlaybackState.paused && !this.isMuted) {
              audio.play().catch(() => {
                console.log('Failed to resume audio after navigation')
              })
            }
          }
        }
      }

      // Add event listeners (only once per controller instance)
      window.addEventListener('audioConsentGranted', this.consentHandler)
      this.toggleBtn.addEventListener('click', this.toggleHandler)
      document.addEventListener('visibilitychange', this.visibilityHandler)
      document.addEventListener('astro:before-swap', this.beforeSwapHandler)
      document.addEventListener('astro:after-swap', this.afterSwapHandler)

      // Check if consent was already given and audio should auto-play
      const consent = localStorage.getItem(this.consentKey)
      if (consent === 'true' && !this.isMuted) {
        this.tryAutoplay()
      }
    }

    updateDOMReferences(audio: HTMLAudioElement, toggleBtn: HTMLElement) {
      // Remove old event listeners before updating references
      if (this.toggleBtn && this.toggleHandler) {
        this.toggleBtn.removeEventListener('click', this.toggleHandler)
      }

      // Update DOM references
      this.audio = audio
      this.toggleBtn = toggleBtn
      this.playingIcon = document.getElementById('music-icon-playing')
      this.mutedIcon = document.getElementById('music-icon-muted')

      // Re-attach toggle handler to new button
      if (this.toggleBtn && this.toggleHandler) {
        this.toggleBtn.addEventListener('click', this.toggleHandler)
      }

      // Update UI to reflect current state
      this.updateUI()
    }

    cleanup() {
      // Remove all event listeners to prevent memory leaks
      if (this.consentHandler) {
        window.removeEventListener('audioConsentGranted', this.consentHandler)
      }
      if (this.toggleHandler && this.toggleBtn) {
        this.toggleBtn.removeEventListener('click', this.toggleHandler)
      }
      if (this.visibilityHandler) {
        document.removeEventListener('visibilitychange', this.visibilityHandler)
      }
      if (this.beforeSwapHandler) {
        document.removeEventListener('astro:before-swap', this.beforeSwapHandler)
      }
      if (this.afterSwapHandler) {
        document.removeEventListener('astro:after-swap', this.afterSwapHandler)
      }
    }

    async handleConsentGranted() {
      // User granted consent via modal, start playing
      if (!this.isMuted && this.audio) {
        try {
          await this.audio.play()
          console.log('Audio playback started after consent')
        } catch (error) {
          console.log('Failed to start audio after consent:', error)
        }
      }
    }

    async tryAutoplay() {
      if (this.isMuted || !this.audio) {
        return
      }

      try {
        await this.audio.play()
      } catch (error) {
        // Autoplay prevented by browser policy
        // Music will start when user grants consent via modal or clicks the toggle
        console.log('Autoplay prevented. Waiting for user consent.')
      }
    }

    toggle() {
      if (!this.audio) return

      this.isMuted = !this.isMuted
      localStorage.setItem('bgMusicMuted', this.isMuted.toString())

      if (this.isMuted) {
        this.audio.pause()
      } else {
        this.audio.play().catch(() => {
          console.error('Failed to play audio')
        })
      }

      this.updateUI()
    }

    updateUI() {
      if (this.isMuted) {
        this.playingIcon?.classList.add('hidden')
        this.mutedIcon?.classList.remove('hidden')
      } else {
        this.playingIcon?.classList.remove('hidden')
        this.mutedIcon?.classList.add('hidden')
      }
    }
  }

  // Global controller instance - stored on window to persist across View Transitions
  declare global {
    interface Window {
      __backgroundMusicController?: BackgroundMusicController
    }
  }

  // Initialize controller if it doesn't already exist
  if (typeof window !== 'undefined') {
    if (!window.__backgroundMusicController) {
      // First time initialization
      if (document.getElementById('background-music')) {
        window.__backgroundMusicController = new BackgroundMusicController()
      }
    } else {
      // Controller already exists from previous page
      // Just update the DOM references since elements persisted
      const audio = document.getElementById('background-music') as HTMLAudioElement
      const toggleBtn = document.getElementById('music-toggle')
      
      if (audio && toggleBtn) {
        window.__backgroundMusicController.updateDOMReferences(audio, toggleBtn)
      }
    }
  }
</script>
